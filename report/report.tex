\documentclass[12pt, a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{graphicx}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{hyperref}
\usepackage{geometry}

\geometry{a4paper, margin=2cm}

\title{Informe de Solución: Planificación de Horarios}
\author{Jackson C. Vera Pineda - estudiante de $4^{to}$ año, Ciencia de la Computación, \\
		facultad de Matemática y Computación, Universidad de La Habana\\\\
		Massiel Paz Otaño - estudiante de $4^{to}$ año, Ciencia de la Computación, \\
		facultad de Matemática y Computación, Universidad de La Habana}


\date{\today}

\begin{document}

\maketitle

\section{Introducción}
Este informe aborda el problema de la planificación de horarios, un problema clásico de optimización combinatoria con múltiples restricciones. El objetivo es diseñar un horario que minimice conflictos, maximice el uso eficiente de recursos y satisfaga las preferencias de los estudiantes y profesores. A continuación, se presenta la formalización del problema, los subproblemas clave, estrategias de solución, análisis de complejidad y demostraciones de correctitud.

\section{Demostración de NP-Completitud}
\begin{itemize}
    \item[\textbf{a)}] \textbf{Pertenece a NP}\\
    Una solución propuesta (un horario con asignaciones de aulas, profesores y tiempos) puede verificarse en tiempo polinomial:
    \begin{itemize}
        \item Comprobar que no hay superposiciones de clases en el mismo aula.
        \item Verificar que los profesores no están asignados a dos clases simultáneamente.
        \item Asegurar que se respetan las preferencias de estudiantes y disponibilidades de recursos.
    \end{itemize}
    Estas verificaciones requieren tiempo proporcional al número de actividades y restricciones, por lo que \textbf{está en NP}.
    \item[\textbf{b)}] \textbf{Es NP-Hard: reducción desde un problema \textbf{NP-Completo}}\\
    Para demostrar que es NP-Hard, reducimos un problema ya conocido como NP-Completo al problema escolar. Usaremos Graph Coloring (coloración de grafos), que es NP-Completo.
    \begin{itemize}
        \item \textbf{Graph Coloring}: Dado un grafo $G = (V, E)$ y $k$ colores, ¿pueden asignarse colores a los nodos de modo que nodos adyacentes no compartan el mismo color?
        \item \textbf{Reducción al problema escolar}:
        \begin{itemize}
            \item \textbf{Nodos del grafo}: Representan clases o exámenes.
            \item \textbf{Aristas del grafo}: Representan conflictos (ejemplo: dos clases que no pueden ocurrir al mismo tiempo).
            \item \textbf{Colores}: Representan bloques de tiempo (horas/días) en el horario.
            \item \textbf{Condiciones adicionales}:
            \begin{itemize}
                \item Aulas como "colores secundarios" (cada color de tiempo debe asignarse a un aula disponible).
                \item Profesores como restricciones de color (un profesor no puede estar en dos clases simultáneas).
            \end{itemize}
        \end{itemize}
    \end{itemize}
    Si podemos resolver el problema escolar, automáticamente resolvemos Graph Coloring. Como Graph Coloring es NP-Completo, el problema escolar es NP-Hard.
\end{itemize}
Por tanto, dado que el problema de planificación de horarios (escolar) está en NP y es NP-Hard, podemos concluir que es NP-Completo

El problema se reduce al problema de coloración de grafos (Graph Coloring), que es NP-Completo.\\
\textbf{Reducción}
\begin{itemize}
    \item Construir un grafo $G$ donde cada nodo representa una clase $c$.
    \item Crear una arista entre dos nodos si comparten: mismo profesor, estudiantes en común (evitar superposición), y/o requisitos de aula especializada.
    \item Asignar colores (pares $(r,t)$) a los nodos
\end{itemize}
Por lo tanto, Si podemos resolver la planificación de horarios en tiempo polinomial, entonces podemos resolver Graph Coloring en tiempo polinomial, lo cual es imposible a menos que $P = NP$.

\section{Formalización del Problema}
El problema se modela como un problema de optimización combinatoria con restricciones duras y blandas. A continuación, se definen los conjuntos, variables, restricciones y función objetivo.

\subsection{Conjuntos y Variables}
\begin{itemize}
    \item \( C = \{c_1, c_2, ..., c_n\} \): Conjunto de cursos/clases.
    \item \( P = \{p_1, p_2, ..., p_m\} \): Conjunto de profesores.
    \item \( S = \{s_1, s_2, ..., s_k\} \): Conjunto de estudiantes.
    \item \( R = \{r_1, r_2, ..., r_l\} \): Conjunto de aulas/recursos.
    \item \( T = \{t_1, t_2, ..., t_q\} \): Conjunto de franjas horarias.
    \item \( x_{c, r, t} \in \{0, 1\} \): Variable binaria que indica si la clase \( c \) se asigna al aula \( r \) en el tiempo \( t \).
    \item \( y_{p, c} \in \{0, 1\} \): Variable binaria que indica si el profesor \( p \) está asignado a la clase \( c \).
    \item \( z_{s, c_1, c_2, t} \in \{0, 1\} \) (solo para versión lineal): Variable auxiliar que indica conflicto para el estudiante \( s \) entre \( c_1 \) y \( c_2 \) en tiempo \( t \).
\end{itemize}

\subsection{Parámetros}
\begin{itemize}
    \item \( E_s \subseteq C \): Clases inscritas por el estudiante \( s \in S \).
    \item \( \text{Capacidad}(r) \in \mathbb{N} \): Capacidad máxima del aula \( r \).
    \item \( \text{Estudiantes}(c) \in \mathbb{N} \): Número de estudiantes en la clase \( c \).
    \item \( \text{Preferencia}_{s,c,t} \in \{0, 1\} \): Preferencia del estudiante \( s \) por la clase \( c \) en tiempo \( t \).
    \item \( \alpha, \beta, \gamma \geq 0 \): Pesos para conflictos, subutilización y preferencias respectivamente.
\end{itemize}


\subsection{Restricciones Duras}
\begin{itemize}
    \item \textbf{No superposición}: 
        \[
        \sum_{c \in C} x_{c, r, t} \leq 1 \quad \forall r \in R, t \in T
        \]
    \item \textbf{Disponibilidad de profesores}:
        \[
        \sum_{c \in C} y_{p, c} \cdot x_{c, r, t} \leq 1 \quad \forall p \in P, t \in T
        \]
    \item \textbf{Aforo}:
        \[
        x_{c, r, t} = 1 \implies \text{Capacidad}(r) \geq \text{Estudiantes}(c) \quad \forall c \in C, r \in R, t \in T
        \]
\end{itemize}

\subsection{Restricciones Blandas y Función Objetivo}
\subsubsection{Versión Cuadrática (Original)}
\[
\begin{aligned}
\text{Minimizar } & \alpha \cdot \underbrace{\sum_{s \in S} \sum_{\substack{c_1, c_2 \in E_s \\ c_1 < c_2}} \sum_{t \in T} \left(\sum_{r_1} x_{c_1, r_1, t}\right)\left(\sum_{r_2} x_{c_2, r_2, t}\right)}_{\text{Conflictos}} \\
& + \beta \cdot \underbrace{\sum_{c, r, t} x_{c, r, t} \cdot \left(\text{Capacidad}(r) - \text{Estudiantes}(c)\right)}_{\text{Subutilización}} \\
& + \gamma \cdot \underbrace{\sum_{s, c \in E_s} \sum_{r, t} x_{c, r, t} \cdot \left(1 - \text{Preferencia}_{s,c,t}\right)}_{\text{Preferencias insatisfechas}}
\end{aligned}
\]

\subsubsection{Versión Linealizada}
\begin{itemize}
    \item \textbf{Restricciones adicionales}:
    \[
    \begin{cases}
    z_{s, c_1, c_2, t} \geq \sum_{r_1} x_{c_1, r_1, t} + \sum_{r_2} x_{c_2, r_2, t} - 1 & \forall s, c_1 < c_2 \in E_s, t \\
    z_{s, c_1, c_2, t} \leq \sum_{r} x_{c_1, r, t} & \forall s, c_1 < c_2 \in E_s, t \\
    z_{s, c_1, c_2, t} \leq \sum_{r} x_{c_2, r, t} & \forall s, c_1 < c_2 \in E_s, t
    \end{cases}
    \]
    
    \item \textbf{Función Objetivo Lineal}:
    \[
    \begin{aligned}
    \text{Minimizar } & \alpha \cdot \underbrace{\sum_{s, c_1 < c_2 \in E_s} \sum_{t} z_{s, c_1, c_2, t}}_{\text{Conflictos (lineal)}} \\
    & + \beta \cdot \text{Subutilización} + \gamma \cdot \text{Preferencias insatisfechas}
    \end{aligned}
    \]
\end{itemize}

\section{Subproblemas Clave y Estrategias de Solución}
\subsection{Subproblema 1: Asignación de Profesores sin Conflictos}
\begin{itemize}
    \item \textbf{Estrategia}: Modelar como un problema de emparejamiento en grafos bipartitos.
    \item \textbf{Formalización}:
    El problema se modela como un grafo bipartito ponderado $G=(T\cup C,E)$ donde:
    \begin{itemize}
        \item$T:$ Conjunto de profesores (nodos en una partición).
        \item$C:$ Conjunto de clases (nodos en la otra partición).
        \item$E:$ Aristas que conectan profesores $t_i$ con clases $c_j$, con pesos $w_{ij}$ que representa el costo de asignar $c_j$ a $t_i$. Si un profesor no puede asignar una clase (por superposición de horarios o falta de disponibilidad), $w_{ij} = \infty$.
    \end{itemize}
    \textbf{Objetivo}: Encontrar un \textbf{emparejamiento perfecto} (asignar cada clase a un profesor y viceversa) que minimice el costo total, garantizando que ningún profesor tenga clases superpuestas y viceversa.
    \item \textbf{Algoritmo}: Algoritmo húngaro.\\
    \textbf{Pasos}:
    \begin{itemize}
        \item[1.] \textbf{Reducción de filas y columnas}: Restar el mínimo de cada fila y luego de cada columna.
        \item[2.] \textbf{Cubrir ceros}: Usar el mínimo de líneas para cubrir todos los ceros en matriz reducida.
        \item[3.] \textbf{Ajustes de costos}:
        \begin{itemize}
            \item Si el número de líneas es igual al de la matriz, se ha encontrado una asignación óptima.
            \item De lo contrario, encontrar el elemento mínimo no cubierto, restárselo a las filas no cubiertas, y sumarlo a las columnas cubiertas. Volver al paso 2.
        \end{itemize}
    \end{itemize}
    \item \textbf{Pseudocódigo}:
    \begin{verbatim}
    Entrada: Matriz de costo n x n (cost).
    Salida: Asignaciones óptimas (match).
    
    1. Inicializar etiquetas para filas (u) y columnas (v)
    2. Para cada fila i:
        - u[i] = min(cost[i][j]) para toda j.
    3. Para cada columna j:
        - v[j] = min(cost[i][j] - u[i]) para toda i.
    4. Usar BFS/DFS para encontrar emparejamientos perfectos.
    5. Repetir hasta encontrar el emparejamiento.
    \end{verbatim}
    \item \textbf{Correctitud}: \\
    Este algoritmo garantiza una asignación óptima debido a:
    \begin{itemize}
        \item \textbf{Teorema de Köning}: Establece que en grafos bipartitos, el tamaño del máximo apareamiento es igual al mínimo número de nodos necesarios para cubrir todas las aristas.
        \item \textbf{Optimalidad}: Cada iteración reduce el costo total potencial hasta alcanzar un apareamiento perfecto con costo mínimo.
    \end{itemize}
    \item \textbf{Complejidad}:\\
    La complejidad es $O(n^3)$, donde $n$ es el número de nodos (clases o profesores, el que sea mayor). Esto se debe a las operaciones de reducción y ajuste iterativo en la matriz de costos.
    \item \textbf{Implementación en Python}:\\
    La biblioteca \textit{scipy} ofrece una implementación eficiente del algoritmo. 
    \begin{verbatim}
    import numpy as np
    from scipy.optimize import linear_sum_assignment
    import time
    
    # Matriz de costos (filas: profesores, columnas: clases)
    # cost[i][j] = costo de asignar la clase j al profesor i
    cost = np.array([
        [3, 1, 2],
        [2, 4, 3],
        [3, 2, 1]
    ])
    
    # Medir el tiempo de inicio
    start_time = time.time()
    
    # Aplicar el Algoritmo Húngaro
    row_ind, col_ind = linear_sum_assignment(cost)
    
    # Medir el tiempo de fin
    end_time = time.time()
    
    # Calcular el tiempo de ejecución
    execution_time = end_time - start_time
    
    # Asignaciones óptimas
    for teacher, class_idx in zip(row_ind, col_ind):
        print(f"Profesor {teacher} -> Clase {class_idx} (Costo: {cost[teacher][class_idx]})")
    
    # Costo total
    print("Costo total:", cost[row_ind, col_ind].sum())
    
    # Imprimir el tiempo de ejecución
    print(f"Tiempo de ejecución: {execution_time:.6f} segundos")
    
    \end{verbatim}
    
    \textbf{Salida}:
    \begin{verbatim}
    Profesor 0 -> Clase 1 (Costo: 1)
    Profesor 1 -> Clase 0 (Costo: 2)
    Profesor 2 -> Clase 2 (Costo: 1)
    Costo total: 4
    Tiempo de ejecución: 0.000000 segundos
    \end{verbatim}
    
\end{itemize}

\subsection{Subproblema 2: Programación de Clases en Aulas y Horarios}
\begin{itemize}
    \item \textbf{Formalización}: Asignar \( (c, r, t) \) sin violar restricciones duras.
    \item \textbf{Estrategia}: Modelar como un problema de coloración de grafos.
    \item \textbf{Algoritmo}: Heurística greedy con ordenamiento por grado de conflicto.
    \item \textbf{Correctitud}: Encuentra una coloración con \( \leq k+1 \) colores.
    \item \textbf{Complejidad}: \( O(n^2) \).
\end{itemize}

\subsection{Subproblema 3: Manejo de Preferencias de Estudiantes}
\begin{itemize}
    \item \textbf{Formalización}: Optimizar restricciones blandas.
    \item \textbf{Estrategia}: Programación lineal entera (ILP) con relajación Lagrangiana.
    \item \textbf{Complejidad}: NP-Hard, pero relajaciones aproximadas en \( O(n^3) \).
\end{itemize}

\subsection{Subproblema 4: Condiciones Aleatorias (Eventos Imprevistos)}
\begin{itemize}
    \item \textbf{Formalización}: Replanificar ante cancelaciones de clases.
    \item \textbf{Estrategia}: Algoritmos online con ventanas deslizantes.
    \item \textbf{Análisis competitivo}: Cota de rendimiento frente al óptimo offline.
\end{itemize}

\section{Cotas Mínimas y Análisis de Complejidad}
\begin{itemize}
    \item \textbf{Cota inferior para el problema general}: cualquier algoritmo exacto requiere \( \Omega(2^n) \) en el peor caso (por la reducción a Graph Coloring).
    \item \textbf{Algoritmos de aproximación}: No se puede aproximar mejor que \( O(n^{1-\epsilon}) \) a menos que \( P = NP \).
\end{itemize}

\section{Estrategias de Solución Parcial/Total}
\begin{itemize}
    \item \textbf{Algoritmos Greedy}: Asignar primero las clases con mayor restricciones.
    \item \textbf{Algoritmos de Aproximación}: ILP con relajación lineal.
    \item \textbf{Metaheurísticas}: Algoritmos genéticos o simulated annealing.
\end{itemize}

\section{Conclusión}
Este informe ha presentado un enfoque estructurado para resolver el problema de planificación de horarios, demostrando su naturaleza NP-Hard y proponiendo estrategias para abordar subproblemas con análisis de complejidad y correctitud. Se recomienda implementar soluciones parciales usando enfoques híbridos o metaheurísticas para instancias grandes.

\end{document}